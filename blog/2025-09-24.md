# First Steps

Bootstrapping the core services has taken longer than I had hoped.  Perhaps because I have deliberately 
avoided coding agents.  I wanted to hand-craft these services to ensure I understood all the working
parts.  I am hoping that decision will pay off later when I am forced to consider various trade-offs.

Talking of trade-offs I have encountered my first.  But first we need to cover the core design:

![core services design](./../.media/core-architecture.excalidraw.png)

**`faker-analytics-api`**

This is our sample "traditional app".  It is a web API.  It was designed for programmatic access.
As such getting started can be difficult.  You need to read a few docs and write many lines of 
code before you can get any value out of it.  I'd like to see if gen AI can lower that initial 
barrier.

It is not important now.  But it exposes several endpoints:

- GET /api/trades
- GET /api/trades/ohlcv

**`faker-analytics-cli`**

My first experiment is focused on provide a natural language interface to the system.  I've decided 
to write a CLI.  Because who has the time to CSS?

**`tool-discovery-service`**

Ok.  I can guess what you are thinking.  _Why have you create a discovery service_?  _What kind of ivory tower is this_?
These are fair points.  For a silly little project like this there is no need for a discovery service.
But I want to consider:

- How do you management multiple tools?
- Written in multiple languages

For that reason I've added the extra complicate of a discovery service.  Which brings me to my first 
trade-off (yay I'm back on point).

It would be nice if our tools had the following properties:

1. Loose coupling with the tools that consume them
2. Can be written in any language
3. Dynamic

Wouldn't it be nice if we could always use the best tool for the job?  Strongly typed languages
complicate this.  Because:

- ✅ Type systems are great; they catch errors at compile time
- ❌ Loading new types _generally_ requires a fresh build
- ❌ New tools need new code paths

But avoiding the negatives has lead me to this:

```cs
// Tools create this and send it to PUT /api/tools/{tool-name}
public class Tool
{
    public required string Name { get; init; }

    // What does the tool do?
    // What parameters does it support?
    // What does it return?
    public required ToolDefinition ToolDefinition { get; init; }

    // Where to find the tool.
    // i.e. GET /api/example?foo=bar
    public required ToolRoute ToolRoute { get; init; }

    // Execute the tool.
    public async Task<JsonObject> ExecuteAsync(JsonObject jsonParameters)
    {
        /* magic smoke here */
    }
}
```

I am not happy with the use of `JsonObject`.  Of course I could do this:

```cs
public class Tool<InType, OutType>
{
    /* snip */

    public async Task<OutType> ExecuteAsync(InType jsonParameters)
    {
        /* magic smoke here */
    }
}

```

But now every tool I create will need to publish its types.  There are a few downsides:

- My CLI app will need to import types from every tool it wants to consume
- My CLI app will probably contain a switch statement with _n_ arms (where _n_ is the number of tools)
- Requires a fresh build to use
- If I write a tool in a dynamic language I will need to write a strongly typed wrapper

I don't really like either approach.  But - for now at least - I have chosen to give up type safety
in favour of freedom and flexibility.  Let's see how that pans out.

[Last](./2025-09-23.md)
